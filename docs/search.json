[
  {
    "objectID": "hodge_podge.html",
    "href": "hodge_podge.html",
    "title": "Hodge Podge",
    "section": "",
    "text": "What is the purpose of the lapply() function? What is the equivalent purrr function?\n\nlapply() applies a function to each element of a named list. The equivalent purrr function is map().\n\nSuppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want use lapply() to run the code cor(numeric_matrix, method = “kendall”) on each element of the list.\n\nlapply(X = my_list, FUN = cor, y = numeric_matrix, method = \"kendall\") additional arguments (y and method) are added after the function call\n\nWhat are two advantages of using purrr functions instead of the BaseR apply family?\n\npurrr offers greater consistency across the functions. In addition, it offers useful variants and helpful functions not available to the apply family.\n\nWhat is a side-effect function?\n\nA side-effect function is …\n\nWhy can you name a variable sd in a function and not cause any issues with the sd function?\n\nBecause the scope of the variable within the function is contained to the local environment."
  },
  {
    "objectID": "hodge_podge.html#task-1-conceptual-questions",
    "href": "hodge_podge.html#task-1-conceptual-questions",
    "title": "Hodge Podge",
    "section": "",
    "text": "What is the purpose of the lapply() function? What is the equivalent purrr function?\n\nlapply() applies a function to each element of a named list. The equivalent purrr function is map().\n\nSuppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want use lapply() to run the code cor(numeric_matrix, method = “kendall”) on each element of the list.\n\nlapply(X = my_list, FUN = cor, y = numeric_matrix, method = \"kendall\") additional arguments (y and method) are added after the function call\n\nWhat are two advantages of using purrr functions instead of the BaseR apply family?\n\npurrr offers greater consistency across the functions. In addition, it offers useful variants and helpful functions not available to the apply family.\n\nWhat is a side-effect function?\n\nA side-effect function is …\n\nWhy can you name a variable sd in a function and not cause any issues with the sd function?\n\nBecause the scope of the variable within the function is contained to the local environment."
  },
  {
    "objectID": "hodge_podge.html#task-2-writing-r-functions",
    "href": "hodge_podge.html#task-2-writing-r-functions",
    "title": "Hodge Podge",
    "section": "Task 2: Writing R Functions",
    "text": "Task 2: Writing R Functions\n\nRoot Mean Squared Error Function\nWrite a basic function (call it getRMSE()) that takes in a vector of responses and a vector of predictions and outputs the Root Mean Squared Error. If a value is missing for the vector of responses (i.e. an NA is present), allow for additional arguments to the mean() function (elipses) that removes the NA values in the computation.\n\ngetRMSE &lt;- function(responses, predictions, ...) {\n  mean &lt;- mean(((responses - predictions)^2),...)\n  sqrt(mean)\n}\n\nRun the following code to create some response values and predictions.\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\nTest your RMSE function using this data.\n\ngetRMSE(resp, pred)\n\n[1] 0.9581677\n\n\nRepeat after replacing two of the response values with missing values (NA_real_).\n\nresp_nas &lt;- resp\nresp_nas[c(2, 52)] &lt;- NA_real_\n\nTest your RMSE function with and without specifying the behavior to deal with missing values.\n\n#without\ngetRMSE(resp_nas, pred)\n\n[1] NA\n\n\n\n#with\ngetRMSE(resp_nas, pred, na.rm = TRUE)\n\n[1] 0.9672233\n\n\n\n\nMean Absolute Error Function\nWrite a function called getMAE() that follows the specifications of the getRMSE() function.\n\ngetMAE &lt;- function(responses, predictions, ...) {\n  mean &lt;- mean((responses - predictions),...)\n  abs(mean)\n}\n\nRun the following code to create some response values and predictions.\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\nTest your MAE function using this data.\n\ngetMAE(resp, pred)\n\n[1] 2.955414e-15\n\n\nRepeat after replacing two of the response values with missing values (NA_real_).\n\nresp_nas &lt;- resp\nresp_nas[c(2, 52)] &lt;- NA_real_\n\nTest your MAE function with and without specifying the behavior to deal with missing values.\n\n#without\ngetMAE(resp_nas, pred)\n\n[1] NA\n\n\n\n#with\ngetMAE(resp_nas, pred, na.rm = TRUE)\n\n[1] 0.001650213"
  },
  {
    "objectID": "hodge_podge.html#task-3-querying-an-api-and-a-tidy-style-function",
    "href": "hodge_podge.html#task-3-querying-an-api-and-a-tidy-style-function",
    "title": "Hodge Podge",
    "section": "Task 3: Querying an API and a Tidy-Style Function",
    "text": "Task 3: Querying an API and a Tidy-Style Function\nLoad required packages\n\nlibrary(conflicted)\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n\nlibrary(httr)\nlibrary(jsonlite)\n\nAPI key: 214a818775454f13ab5ccf959e471a0f\n\nsubject &lt;- \"election\"\napi_key &lt;- \"214a818775454f13ab5ccf959e471a0f\"\nstart_date &lt;- today() - 30\nURL_base &lt;- \"https://newsapi.org/v2/everything?q=\"\nURL_id &lt;- paste0(URL_base, subject, \"&from=\", start_date, \"&sortBy=publishedAt&apiKey=\", api_key)\n\nUse GET() from the httr package to return information about a topic that you are interested in that has been in the news lately (store the result as an R object).\n\nnews_raw &lt;- GET(URL_id)\nnews_stories &lt;- fromJSON(rawToChar(news_raw$content))\nnews_stories &lt;- as_tibble(news_stories)"
  }
]